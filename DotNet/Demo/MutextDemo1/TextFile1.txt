
在有着N个CPU的机器上，一个线程只能在给定的时间上在一个CPU上运行，因为每个线程都是一个代码段，
每个CPU一次只能运行一段代码。而看起来像是N个同时完成是线程间共享CPU时间片的效果。

这个例子里，我们将创建另一个线程，我们将用两个线程演示多线程的工作方式，
最后，我们实现两个线程(主线程与新线程)同步，在新线程工作前必须等待消息。
建立线程前我们必须引入System.Threading命名空间。然后我需要知道的是，线程得为控制流程建立一个起点。
起点是一个函数，可以使一个相同的调用或其它。

在完成上面程序后，设想我们不想在一开始新线程就让它马上运行结束，
也就是说，我们开启了一个新线程，让它运行，在某个特定的时间点，
新线程暂停并等待从主线程(或其他线程)发来的消息。
我们可以这样定义：
  public static ManualResetEvent mre = new ManualResetEvent(false);
ManualResetEvent建立时是把false作为start的初始状态，这个类用于通知另一个线程，让它等待一个或多个线程。
注意，为了通知或监听同一个线程，所有的其它线程都能访问那个类。
等待线程这样写：
  mre.WaitOne();
这将引起等待线程无限期的阻塞并等待类来通知。
发信号的线程应该这样：
  mre.Set();
这样类就会被通知，值变成true，等待线程就会停止等待。
在通知事件发生后，我们就可以使用下面语句把线程置于基状态：
  mre.Reset();


