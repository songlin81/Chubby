    *** 浮点运算的问题 ***

在JavaScript中进行纯小数运算偶尔会得到不正确的结果:

> 0.1 + 0.2 == 0.3
false
> 0.1 + 0.2
0.30000000000000004

很多人马上就开始认为JavaScript设计的不成熟,设计上有缺陷。
实际上这并不是JavaScript仅有的问题，C/C++/Java甚至Matlab都有这个问题，参见: why 0.3-0.2-0.1 not equal to zero。
这只是JavaScript遵循IEEE 754标准所产生的必然结果。IEEE 754标准中的浮点数并不能精确地表达小数（比如说0.1），

    你需要足够的内存来保留5个数字
    你需要使用一个取值范围来确保精度。

在硬件层面，除法是转换成乖法来表示的，比如：　Z　=　X/Y　会变成 Z = X * (1/Y)；

JavaScript中的小数采用的是双精度(64位)表示的，由三部分组成：　符 + 阶码 + 尾数，在十进制中的 1/10，在十进制中可以简单写为 0.1 ，
但在二进制中，他得写成：0.0001100110011001100110011001100110011001100110011001…..（后面全是 1001 循环）。
因为浮点数只有52位有效数字，从第53位开始，就舍入了。这样就造成了“浮点数精度损失”问题。 （参考：　出处1, 出处2）
所以你在处理小数运算时要非常小心。

怎么解决

就像标准中提到的，我们可以采用一个精确范围来比较是否相等
    x = 0.2;
    y = 0.3;
    equal = (Math.abs(x - y) < 0.000001)

第二种方法是使用JavaScript内置的函数toPrecision或toFixed来保留一定的精度：
    (0.1 + 0.2).toPrecision(10) == 0.3
    > true
    (0.1 + 0.2).toFixed(10) == 0.3
    > true
